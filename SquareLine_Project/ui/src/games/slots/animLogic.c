// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 9.1.0
// Project name: SquareLine_Project

#include "animLogic.h"
#include "../../ui_events.h"
#include "../../ui.h"
#include <stdio.h> // For debugging (optional)
#include "../../../mp3_player.h"
// Forward declarations
static void anim_y_cb(void *var, int32_t v);
static void slot_roll_timer_cb(lv_timer_t *timer);
static void stop_slot_animation(lv_timer_t *timer);
static void normalize_positions_after_stop(lv_timer_t *timer);

// New: Callback type definition for slot stop event
typedef void (*slot_stop_event_cb_t)(int column_index);

// New: Global variable to store the stop event callback
static slot_stop_event_cb_t slot_stop_event_cb = NULL;

// Add a global array to track active animations by column
static lv_timer_t *active_timers[3] = {NULL, NULL, NULL}; // For up to 3 columns
static lv_timer_t *roll_timers[3] = {NULL, NULL, NULL}; // Timers for continuous rolling

// Fixed predefined positions to ensure consistency
static const int32_t VALID_POSITIONS[5] = {-120, -60, 0, 60, 120};

// Boundaries
static const int32_t TOP_BOUNDARY = -180;
static const int32_t BOTTOM_BOUNDARY = 180;

// Add a global array to track target items for each column
static lv_obj_t *target_items[3] = {NULL, NULL, NULL}; // Store target item for each column

// Simple animation callback that just sets the Y position directly
static void anim_y_cb(void *var, int32_t v) {
    lv_obj_t *obj = (lv_obj_t *)var;
    lv_obj_set_y(obj, v);
}

// Timer callback for continuous rolling (like real slots)
static void slot_roll_timer_cb(lv_timer_t *timer) {
    lv_obj_t *parent = (lv_obj_t *)timer->user_data;
    if (!parent) return;
    
    // Determine which column this is
    int column_index = -1;
    if (parent == ui_slotColumn0) column_index = 0;
    else if (parent == ui_slotColumn1) column_index = 1;
    else if (parent == ui_slotColumn2) column_index = 2;
    
    // Get all children and move them down
    uint32_t child_count = lv_obj_get_child_cnt(parent);
    
    for (uint32_t i = 0; i < child_count; i++) {
        lv_obj_t *item = lv_obj_get_child(parent, i);
        int32_t current_y = lv_obj_get_y(item);
        
        // Move down by a small increment for smooth scrolling
        int32_t new_y = current_y + 15; // Adjust speed as needed
        
        // If item goes below the bottom boundary, wrap it to the top
        if (new_y > BOTTOM_BOUNDARY) {
            // Find the topmost item
            int32_t topmost_y = BOTTOM_BOUNDARY;
            for (uint32_t j = 0; j < child_count; j++) {
                if (j == i) continue; // Skip current item
                lv_obj_t *other = lv_obj_get_child(parent, j);
                int32_t other_y = lv_obj_get_y(other);
                if (other_y < topmost_y) {
                    topmost_y = other_y;
                }
            }
            // Position this item above the topmost item
            new_y = topmost_y - 60; // One slot position above
            
            printf("Column %d: Item %d wrapped from bottom to top: %d\n", 
                   column_index, i, new_y);
        }
        
        // Set the new position directly
        lv_obj_set_y(item, new_y);
    }
}

void start_slot_animation(lv_obj_t *parent) {
    if (!parent) return;

    // Determine which column this is
    int column_index = -1;
    if (parent == ui_slotColumn0) column_index = 0;
    else if (parent == ui_slotColumn1) column_index = 1;
    else if (parent == ui_slotColumn2) column_index = 2;
    
    printf("Starting animation for column %d\n", column_index);
    
    // If there's an active timer for this column, cancel it first
    if (column_index >= 0) {
        if (active_timers[column_index] != NULL) {
            lv_timer_del(active_timers[column_index]);
            active_timers[column_index] = NULL;
        }
        
        if (roll_timers[column_index] != NULL) {
            lv_timer_del(roll_timers[column_index]);
            roll_timers[column_index] = NULL;
        }
    }

    uint32_t child_count = lv_obj_get_child_cnt(parent);
    if (child_count < 5) return; // Need 5 items

    // First, clear all animations to avoid conflicts
    for (uint32_t i = 0; i < child_count; i++) {
        lv_obj_t *item = lv_obj_get_child(parent, i);
        lv_anim_del(item, NULL);
    }

    // IMPORTANT: Always reset to original positions before starting
    for (uint32_t i = 0; i < 5; i++) {
        lv_obj_t *item = lv_obj_get_child(parent, i);
        lv_obj_set_y(item, VALID_POSITIONS[i]);
        printf("Column %d: Reset item %d to position %d\n", column_index, i, VALID_POSITIONS[i]);
    }

    // Create a timer to continuously roll the slots
    lv_timer_t *roll_timer = lv_timer_create(slot_roll_timer_cb, 40, parent); // 40ms interval
    
    // Store the timer reference
    if (column_index >= 0) {
        roll_timers[column_index] = roll_timer;
        printf("Set roll timer for column %d\n", column_index);
    }
}

static void normalize_positions_after_stop(lv_timer_t *timer) {
    lv_obj_t *parent = (lv_obj_t *)timer->user_data;
    if (!parent) return;
    
    // Determine which column this is
    int column_index = -1;
    if (parent == ui_slotColumn0) column_index = 0;
    else if (parent == ui_slotColumn1) column_index = 1;
    else if (parent == ui_slotColumn2) column_index = 2;
    
    uint32_t child_count = lv_obj_get_child_cnt(parent);
    
    // Clear any remaining animations
    for (uint32_t i = 0; i < child_count; i++) {
        lv_obj_t *item = lv_obj_get_child(parent, i);
        lv_anim_del(item, NULL);
    }
    
    // Use the stored target item for this column
    lv_obj_t *target_item = (column_index >= 0) ? target_items[column_index] : NULL;
    
    printf("Column %d: Normalizing with target item: %p\n", column_index, (void*)target_item);
    
    // If we found a target item
    if (target_item && child_count >= 5) {
        // Find the index of our target item
        int center_item_idx = -1;
        for (uint32_t i = 0; i < child_count; i++) {
            if (lv_obj_get_child(parent, i) == target_item) {
                center_item_idx = i;
                break;
            }
        }
        
        if (center_item_idx >= 0) {
            printf("Column %d: Target item found at index %d\n", column_index, center_item_idx);
            
            // We need to show 5 items: 2 above center, center, and 2 below center
            // For each position in the VALID_POSITIONS array, we need to find the right item
            
            // First ensure our indices will wrap properly at column boundaries
            int above_2_idx = (center_item_idx - 2 + child_count) % child_count;
            int above_1_idx = (center_item_idx - 1 + child_count) % child_count;
            int below_1_idx = (center_item_idx + 1) % child_count;
            int below_2_idx = (center_item_idx + 2) % child_count;
            
            printf("Column %d: Indices: above2=%d, above1=%d, center=%d, below1=%d, below2=%d\n",
                   column_index, above_2_idx, above_1_idx, center_item_idx, below_1_idx, below_2_idx);
            
            // Position all 5 items in the correct spots
            lv_obj_t *above_2 = lv_obj_get_child(parent, above_2_idx);
            lv_obj_t *above_1 = lv_obj_get_child(parent, above_1_idx);
            lv_obj_t *center = lv_obj_get_child(parent, center_item_idx);
            lv_obj_t *below_1 = lv_obj_get_child(parent, below_1_idx);
            lv_obj_t *below_2 = lv_obj_get_child(parent, below_2_idx);
            
            // Set final positions directly - for more reliability
            if (above_2) lv_obj_set_y(above_2, VALID_POSITIONS[0]);
            if (above_1) lv_obj_set_y(above_1, VALID_POSITIONS[1]);
            if (center) lv_obj_set_y(center, VALID_POSITIONS[2]); // Center (0)
            if (below_1) lv_obj_set_y(below_1, VALID_POSITIONS[3]);
            if (below_2) lv_obj_set_y(below_2, VALID_POSITIONS[4]);
            
            printf("Column %d: Final positions set with target item %d at center\n", 
                  column_index, center_item_idx);
        }
    } else {
        // Fallback - just set all items to the standard positions
        for (uint32_t i = 0; i < child_count && i < 5; i++) {
            lv_obj_t *item = lv_obj_get_child(parent, i);
            lv_obj_set_y(item, VALID_POSITIONS[i]);
            
            printf("Column %d: Fallback snap - Item %d to position %d\n", 
                   column_index, i, VALID_POSITIONS[i]);
        }
    }

    // Clear the stored target item
    if (column_index >= 0) {
        target_items[column_index] = NULL;
    }

    mp3_stop_advertisement();
    mp3_play_advertisement(3, 80);

    if (slot_stop_event_cb != NULL && column_index == 2) {
        slot_stop_event_cb(column_index);
        printf("Column %d: Stop event triggered\n", column_index);
    }
}

static void stop_slot_animation(lv_timer_t *timer) {
    slot_stop_data_t *data = (slot_stop_data_t *)timer->user_data;
    if (!data || !data->parent || !data->target_item) {
        if (data) free(data);
        return;
    }

    lv_obj_t *parent = data->parent;
    lv_obj_t *target_item = data->target_item;
    
    // Determine which column this is
    int column_index = -1;
    if (parent == ui_slotColumn0) column_index = 0;
    else if (parent == ui_slotColumn1) column_index = 1;
    else if (parent == ui_slotColumn2) column_index = 2;
    
    printf("Column %d: Stopping at target item: %p\n", column_index, (void*)target_item);
    
    // Store the target item for later use in the normalize function
    if (column_index >= 0) {
        target_items[column_index] = target_item;
    }
    
    // First, delete the roll timer to stop continuous movement
    if (column_index >= 0 && roll_timers[column_index] != NULL) {
        lv_timer_del(roll_timers[column_index]);
        roll_timers[column_index] = NULL;
    }
    
    if (column_index >= 0) {
        active_timers[column_index] = NULL;
    }
    
    uint32_t child_count = lv_obj_get_child_cnt(parent);
    
    // Stop all existing animations
    for (uint32_t i = 0; i < child_count; i++) {
        lv_obj_t *item = lv_obj_get_child(parent, i);
        lv_anim_del(item, NULL);
    }
    
    // Add a cleanup timer to finalize positions immediately
    lv_timer_t *cleanup_timer = lv_timer_create(normalize_positions_after_stop, 0, parent);
    lv_timer_set_repeat_count(cleanup_timer, 1);

    free(data);
    timer->user_data = NULL;
}

void stop_at_item(lv_obj_t *item_name, uint32_t delay) {
    uint32_t delay_ms = delay;
    printf("stop_at_item called: %p, delay: %u ms\n", (void*)item_name, delay_ms);
    
    lv_obj_t *target_item = item_name;
    
    if (!target_item) {
        printf("Target item is NULL\n");
        return;
    }
    
    lv_obj_t *parent = lv_obj_get_parent(target_item);
    if (!parent) {
        printf("Parent is NULL\n");
        return;
    }
    
    // Determine which column this is
    int column_index = -1;
    if (parent == ui_slotColumn0) column_index = 0;
    else if (parent == ui_slotColumn1) column_index = 1;
    else if (parent == ui_slotColumn2) column_index = 2;
    
    // Store target item immediately for immediate stops
    if (column_index >= 0) {
        target_items[column_index] = target_item;
        printf("Column %d: Target item set to %p\n", column_index, (void*)target_item);
    }
    
    // If there's an active timer for this column, cancel it first
    if (column_index >= 0 && active_timers[column_index] != NULL) {
        lv_timer_del(active_timers[column_index]);
        active_timers[column_index] = NULL;
        printf("Cancelled previous timer for column %d\n", column_index);
    }
    
    slot_stop_data_t *data = malloc(sizeof(slot_stop_data_t));
    if (!data) {
        printf("Failed to allocate memory for timer data\n");
        return;
    }
    data->parent = parent;
    data->target_item = target_item;
    
    lv_timer_t *stop_timer = lv_timer_create(stop_slot_animation, delay_ms, data);
    if (!stop_timer) {
        printf("Failed to create timer\n");
        free(data);
        return;
    }
    
    // Store the timer reference
    if (column_index >= 0) {
        active_timers[column_index] = stop_timer;
        printf("Set active timer for column %d to %p\n", column_index, (void*)stop_timer);
    }
    
    lv_timer_set_repeat_count(stop_timer, 1);
}

// New: Function to set the slot stop event callback
void set_slot_stop_event_callback(slot_stop_event_cb_t callback) {
    slot_stop_event_cb = callback;
    printf("Slot stop event callback set to %p\n", (void*)callback);
}