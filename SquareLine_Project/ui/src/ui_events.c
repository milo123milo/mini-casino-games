// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 9.1.0
// Project name: SquareLine_Project
#include "ui_events.h"
#include "ui.h"
#include <lvgl.h>
#include "ui_comp_hook.h"
#include "store/store.h"
#include <stdio.h> // For debugging (optional)
#include "games/slots/animLogic.h"
#include "games/slots/iconRandomizer.h"
#include <esp_system.h> // For esp_random()
#include "../mp3_player.h"
#include "games/dices/diceAnimation.h"
#include "games/blackjack/blackjack.h"

// Add these at the top of the file with other function prototypes
static void restart_game_cb(lv_timer_t *timer);
static void dealer_turn_cb(lv_timer_t *timer);
static void flip_dealer_card(void);
static void flip_dealer_card_ready_cb(lv_anim_t * a);
static void dealer_turn_start_timer_cb(lv_timer_t *timer);
static void reset_player_cards(void);
static void reset_dealer_cards(void);

// Add these at the top with your other static variables
static int arrowScrollPosition = 0;  // Track the scroll position
#define ITEM_WIDTH 150  // Fixed width per item
#define ITEM_COUNT 3  // Total number of items
static lv_obj_t *money_label_slots = NULL; // Reference to label
static lv_obj_t *money_label = NULL; // Reference to label
static lv_obj_t *bet_amount_slots = NULL; // Reference to label
static lv_obj_t *money_label_dice_roll = NULL; // Reference to label
static lv_obj_t *bet_amount_dice_roll = NULL; // Reference to label
static lv_obj_t *bet_amount_black_jack = NULL; // Reference to label
static lv_obj_t *money_label_black_jack = NULL; // Reference to label


lv_obj_t *selected_icons[SELECTED_COUNT];

// Add these at the top with your other static variables
static uint32_t last_arrow_press_time = 0;
#define DEBOUNCE_TIME_MS 300  // Adjust this value to control debounce sensitivity

// Add this at the top with your other static variables if not already there
static lv_timer_t *button_reset_timer = NULL;

// Add this at the top of your file with other global variables
static uint32_t last_hit_btn_time = 0;
static int current_player_card = 0;
static lv_obj_t* player_cards[5]; // Array to hold player card objects
static bool player_cards_initialized = false;

// Add this at the top with other global variables
static lv_timer_t *blackjack_buttons_timer = NULL;

// Add these at the top with other global variables
static int current_dealer_card = 0;
static lv_obj_t* dealer_cards[5]; // Array to hold dealer card objects
static bool dealer_cards_initialized = false;
static lv_timer_t *dealer_turn_timer = NULL;

// Add this at the top with other global variables
static lv_timer_t *restart_game_timer = NULL;

// Add this at the top with other global variables
static uint32_t last_stand_btn_time = 0;
static bool dealer_turn_in_progress = false;

// Add this at the top with other global variables
static lv_timer_t *back_button_enable_timer = NULL;

// Structure to pass multiple parameters to timer callbacks
typedef struct {
    lv_obj_t *card;
    int card_index;
} flip_card_data_t;

// Timer callback function to re-enable the button
static void enable_roll_button_cb(lv_timer_t *timer) {
    lv_obj_clear_state(ui_rollDiceBtn, LV_STATE_DISABLED);
    lv_obj_add_state(ui_rollDiceBtn, LV_IMAGEBUTTON_STATE_RELEASED);
    lv_obj_invalidate(ui_rollDiceBtn);

	lv_obj_clear_state(ui_backButtonDiceRoll, LV_STATE_DISABLED);
    lv_obj_add_state(ui_backButtonDiceRoll, LV_IMAGEBUTTON_STATE_RELEASED);
    lv_obj_invalidate(ui_backButtonDiceRoll);
    
    // Delete the timer since we only need it once
    lv_timer_del(timer);
    button_reset_timer = NULL;
}

// Callback function to enable the buttons after delay
static void enable_blackjack_buttons_cb(lv_timer_t * timer) {
    // Enable the hit and stand buttons
    lv_obj_clear_state(ui_hitBtn, LV_STATE_DISABLED);
    lv_obj_clear_state(ui_standBtn, LV_STATE_DISABLED);
}

void create_snapping_scroll(lv_obj_t * parent)
{
    // Enable scrolling for the container
    lv_obj_set_scroll_dir(parent, LV_DIR_HOR);
    
    // Enable snapping behavior
    lv_obj_set_scroll_snap_x(parent, LV_SCROLL_SNAP_CENTER);
}


void homeScreenLoad(lv_event_t * e)
{
	// Your code here
	if(get_boot_flag() == 1){
		money_label = ui_comp_get_child(ui_coinAmontLabel, UI_COMP_COINAMONTLABEL_COINAMONTLABEL);
		update_money(0, 1, true, money_label);
		mp3_stop_repeat();
	} 


	mp3_play_track(2);
	mp3_start_repeat();
 	create_snapping_scroll(ui_menuSlide);

}

void leftArrowPressed(lv_event_t * e)
{
    uint32_t current_time = lv_tick_get();
    
    // Check if enough time has passed since last button press
    if(current_time - last_arrow_press_time < DEBOUNCE_TIME_MS) {
        return;  // Exit without processing if pressed too soon
    }
    
    // Update the last press time
    last_arrow_press_time = current_time;
    
    // Original button handling code
    mp3_play_advertisement(1, 200);
    if (arrowScrollPosition == 0) {
        arrowScrollPosition = ITEM_COUNT - 1;  // Loop to last item
    } else {
        arrowScrollPosition--;
    }

    lv_obj_scroll_to_x(ui_menuSlide, arrowScrollPosition * ITEM_WIDTH, LV_ANIM_ON);
}

void rightArrowPressed(lv_event_t * e)
{	
    uint32_t current_time = lv_tick_get();
    
    // Check if enough time has passed since last button press
    if(current_time - last_arrow_press_time < DEBOUNCE_TIME_MS) {
        return;  // Exit without processing if pressed too soon
    }
    
    // Update the last press time
    last_arrow_press_time = current_time;
    
    // Original button handling code
    mp3_play_advertisement(1, 200);
    if (arrowScrollPosition == ITEM_COUNT - 1) {
        arrowScrollPosition = 0;  // Loop to first item
    } else {
        arrowScrollPosition++;
    }

    lv_obj_scroll_to_x(ui_menuSlide, arrowScrollPosition * ITEM_WIDTH, LV_ANIM_ON);
}



void coinsAmountHome(lv_event_t * e)
{
	
    
}



void slotsMoneyBarLoaded(lv_event_t * e)
{

	money_label_slots = ui_comp_get_child(ui_coinAmountLabelSlots, UI_COMP_COINAMOUNTLABELSLOTS_COINAMOUNTLABELSLOTS);
    if (money_label_slots == NULL) return;
    update_money(0, 1600, true, money_label_slots);
	
}

void betAmountLoaded(lv_event_t * e)
{
	// Your code here
	mp3_play_track(3);
	mp3_start_repeat();
	bet_amount_slots = ui_comp_get_child(ui_betAmountSlots, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
	set_bet_value(bet_amount_slots, 0);
}

void minusBetSlots(lv_event_t * e)
{

	bet_amount_slots = ui_comp_get_child(ui_betAmountSlots, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
	set_bet_value(bet_amount_slots, -100);
}

void plusBetSlots(lv_event_t * e)
{

	bet_amount_slots = ui_comp_get_child(ui_betAmountSlots, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
	set_bet_value(bet_amount_slots, 100);
}

void verify_container(lv_obj_t* container) {
    uint32_t child_count = lv_obj_get_child_cnt(container);
    printf("Number of children in container: %d\n", child_count);

    for (int i = 0; i < child_count; i++) {
        lv_obj_t* child = lv_obj_get_child(container, i);
        printf("Child %d: %p\n", i, (void*)child);
    }
}

void updateMoneyAfterSpin(int column_index){

	lv_obj_t *selected_icons_test[SELECTED_COUNT];
	selected_icons_test[0] = ui_sevenIcon;
	selected_icons_test[1] = ui_sevenIcon1;
	selected_icons_test[2] = ui_sevenIcon2;

	
	
	int multiplier = process_slot_result(selected_icons);
	uint16_t betAmount = get_bet_amount();
	uint32_t currentMoney = get_money();
	int earned = betAmount * multiplier;
	bool anim = true;

	if(earned == 0){
		anim = false;

		mp3_play_advertisement_with_stop(5, 250);
	}else {
		if(multiplier == 10){
			jackpotAnim_Animation(ui_jackpotImg, 250);
			mp3_play_advertisement_with_stop(6, 250);
		}else{
			mp3_play_advertisement_with_stop(4, 250);
		}
	} 



	printf("Multiplier: %d\n", multiplier);
	printf("Bet Amount: %u\n", betAmount);
	printf("Current Money: %u\n", currentMoney);
	printf("Earned: %d\n", earned);
	printf("Animation: %s\n", anim ? "true" : "false");

	update_money(earned, 600, anim, money_label_slots);

	if(betAmount > get_money() && get_money() == 0){
		set_bet_value(bet_amount_slots, get_money());
		lv_obj_add_state(ui_spinBtn, LV_STATE_DISABLED);
	} else {
		if(betAmount > get_money()){
			set_bet_value(bet_amount_slots, get_money());
		}
		lv_obj_clear_state(ui_spinBtn, LV_STATE_DISABLED);
		lv_obj_add_state(ui_spinBtn, LV_IMAGEBUTTON_STATE_RELEASED);
		lv_obj_invalidate(ui_spinBtn); 
	}

		lv_obj_clear_state(ui_backButtonSlots, LV_STATE_DISABLED);
		lv_obj_add_state(ui_backButtonSlots, LV_IMAGEBUTTON_STATE_RELEASED);
		lv_obj_invalidate(ui_backButtonSlots); 

	
	
	mp3_stop_repeat_with_delay(300);
	mp3_play_track_with_delay(3, 700);
	mp3_start_repeat_with_delay(1100);
	


}



void spinSlotBtn(lv_event_t * e)
{
    //verify_container(ui_slotColumn1);
	srand(esp_random()); // Seed for randomness

	
	uint16_t betAmount = get_bet_amount();
	update_money(-betAmount, 100, true, money_label_slots);

	set_slot_stop_event_callback(updateMoneyAfterSpin);

	lv_obj_add_state(ui_backButtonSlots, LV_STATE_DISABLED);
	lv_obj_add_state(ui_spinBtn, LV_STATE_DISABLED);


	get_random_icons(selected_icons);
    // Get 3 random objects
	    // Example logic: Assign a unique value based on selected icons
		printf("Selected Icons:\n");
		for (int i = 0; i < SELECTED_COUNT; i++) {
			printf("Icon %d: %p\n", i, (void *)selected_icons[i]);  
			// If you have a label or identifier, print it instead of the pointer.
		}



	mp3_play_track(4);
	


	start_slot_animation(ui_slotColumn0);
	stop_at_item(selected_icons[0], 4000);
	//stop_at_item(ui_sevenIcon, 4000);

    start_slot_animation(ui_slotColumn1);
	stop_at_item(selected_icons[1], 4500); 
	//stop_at_item(ui_sevenIcon1, 4500);

	start_slot_animation(ui_slotColumn2);
	stop_at_item(selected_icons[2], 5000);  
	//stop_at_item(ui_sevenIcon2, 5000);

	
	
}

void playIntroLogoSound(lv_event_t * e)
{
	// Your code here
	mp3_play_track(1);

}

void spkButton(lv_event_t * e)
{
	// Your code here
	int spkState = get_spk_state();
	//State machine for spk button using switch case
	switch(spkState){
		case 0:
			mp3_set_volume(20);
			set_spk_state(1);
			break;
		case 1:
			mp3_set_volume(0);
			set_spk_state(0);
			break;
	}

}

void homeGameButton1(lv_event_t * e)
{
	// Your code here
	mp3_play_advertisement(2, 5);
}

void homeGameButton2(lv_event_t * e)
{
	// Your code here
	mp3_play_advertisement(2, 5);
}

void homeGameButton3(lv_event_t * e)
{
	// Your code here
	mp3_play_advertisement(2, 5);
}

void updateMoneyAfterDiceRoll(int dice1, int dice2) 
{
	// Your code here
	money_label_dice_roll = ui_comp_get_child(ui_coinAmountLabelDiceRoll, UI_COMP_COINAMONTLABEL_COINAMONTLABEL);
	int bet = get_bet_amount();

	int betMultiplier = process_dice_result(dice1, dice2);
	if(betMultiplier == 5) {
		mp3_play_advertisement_with_stop(8, 400);
		update_money(bet * betMultiplier, 1, true, money_label_dice_roll);
		button_reset_timer = lv_timer_create(enable_roll_button_cb, 4500, NULL);
	} else if(betMultiplier == 1){
		mp3_play_advertisement_with_stop(9, 400); 
		update_money(bet * (-betMultiplier), 1, true, money_label_dice_roll);
		button_reset_timer = lv_timer_create(enable_roll_button_cb, 4500, NULL);

	} else {
		button_reset_timer = lv_timer_create(enable_roll_button_cb, 1400, NULL);
	}

	// Set a timer to re-enable the button after 1.5 seconds (or your preferred delay)

	lv_timer_set_repeat_count(button_reset_timer, 1);  // Run the timer only once
}

void diceRollScreenLoaded(lv_event_t * e)
{
	lv_obj_add_state(ui_rollDiceBtn, LV_STATE_DISABLED);
	lv_obj_add_state(ui_backButtonDiceRoll, LV_STATE_DISABLED);
	
	// Your code here
	mp3_stop_repeat();
	mp3_play_track(5);
	mp3_start_repeat();

	mp3_play_advertisement(7, 100);

	bet_amount_dice_roll = ui_comp_get_child(ui_betAmountDiceRoll, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);

	set_bet_value(bet_amount_dice_roll, 0);

	money_label_dice_roll = ui_comp_get_child(ui_coinAmountLabelDiceRoll, UI_COMP_COINAMONTLABEL_COINAMONTLABEL);
	update_money(0, 1, true, money_label_dice_roll);

	// Initialize dice references
	init_dice_references();
	
	// Set callback for dice roll completion
	set_dice_roll_complete_callback(updateMoneyAfterDiceRoll);

	button_reset_timer = lv_timer_create(enable_roll_button_cb, 4000, NULL);
	lv_timer_set_repeat_count(button_reset_timer, 1);  // Run the timer only once

}

void minusBetDiceRoll(lv_event_t * e)
{
	// Your code here
	bet_amount_dice_roll = ui_comp_get_child(ui_betAmountDiceRoll, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
	set_bet_value(bet_amount_dice_roll, -100);
	
}

void rollDiceBtn(lv_event_t * e)
{

	lv_obj_add_state(ui_rollDiceBtn, LV_STATE_DISABLED);
	lv_obj_add_state(ui_backButtonDiceRoll, LV_STATE_DISABLED);
	uint32_t current_time = lv_tick_get();
    
    // Check if enough time has passed since last button press
    if(current_time - last_arrow_press_time < 500) {
        return;  // Exit without processing if pressed too soon
    }
    
    // Update the last press time
    last_arrow_press_time = current_time;

    // Initialize dice references if not done yet
	mp3_play_advertisement(7, 250);
    roll_dice();
	
        

}



void plusBetDiceBtn(lv_event_t * e)
{
	bet_amount_dice_roll = ui_comp_get_child(ui_betAmountDiceRoll, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
	set_bet_value(bet_amount_dice_roll, 100);
}

void diceRollScreenUnloaded(lv_event_t * e)
{
	
    reset_dice_visibility();
}

void blackJackUnloaded(lv_event_t * e)
{
    // Cancel any active timers
	/*/
    if (dealer_turn_timer != NULL) {
        lv_timer_del(dealer_turn_timer);
        dealer_turn_timer = NULL;
    }
    
    if (blackjack_buttons_timer != NULL) {
        lv_timer_del(blackjack_buttons_timer);
        blackjack_buttons_timer = NULL;
    }
    
    if (restart_game_timer != NULL) {
        lv_timer_del(restart_game_timer);
        restart_game_timer = NULL;
    }
    */
    // Reset card counters
    current_player_card = 0;
    current_dealer_card = 0;
    
    // Reset dealer_turn_in_progress flag
    dealer_turn_in_progress = false;
    
    // Reset last button press times
    last_hit_btn_time = 0;
    last_stand_btn_time = 0;
    
    // Reset player and dealer cards
	reset_deck();
	reset_player_cards_arr();
	reset_dealer_cards_arr();
    reset_player_cards();
    reset_dealer_cards();
    
    // Hide all player and dealer cards
    if (player_cards_initialized) {
        for (int i = 0; i < 5; i++) {
            lv_obj_add_flag(player_cards[i], LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_opa(player_cards[i], 0, 0);
        }
    }
    
    if (dealer_cards_initialized) {
        for (int i = 0; i < 5; i++) {
            lv_obj_add_flag(dealer_cards[i], LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_opa(dealer_cards[i], 0, 0);
        }
    }
    
    // Reset score displays
    lv_label_set_text(ui_playerPoints, "0");
    lv_label_set_text(ui_dealerPoints, "0");
    
    // Reset specific card opacities
    lv_obj_set_style_opa(ui_playerCard1, 0, 0);
    lv_obj_set_style_opa(ui_dealercard1, 0, 0);
    lv_obj_set_style_opa(ui_dealercard2, 0, 0);
    lv_obj_set_style_opa(ui_pointsBar, 0, 0);
    lv_obj_set_style_opa(ui_pointsboxDealer, 0, 0);
    lv_obj_set_style_opa(ui_playercardsframe, 0, 0);
    lv_obj_set_style_opa(ui_pointsboxPlayer, 0, 0);
    lv_obj_set_style_opa(ui_standBtn, 0, 0);
    lv_obj_set_style_opa(ui_hitBtn, 0, 0);
    lv_obj_set_style_opa(ui_dealerPoints, 0, 0);
    lv_obj_set_style_opa(ui_playerPoints, 0, 0);
    
    // Reset the game state
    //start_new_blackjack_game();
    
    // Setup dealer's initial cards (both facing back)
    for (int i = 0; i < 5; i++) {
        if (dealer_cards_initialized) {
            if (i < 2) {
                // First two dealer cards are visible but face down
                lv_obj_clear_flag(dealer_cards[i], LV_OBJ_FLAG_HIDDEN);
               // lv_obj_set_style_opa(dealer_cards[i], 255, 0);
                lv_image_set_src(dealer_cards[i], get_card_image("BACK"));
                // Make sure both cards are animated, with a slight delay between them
               // cardPullAnim_Animation(dealer_cards[i], i * 200); // Use cardPull for initial dealing
            } else {
                // Hide the rest of dealer's cards
                lv_obj_add_flag(dealer_cards[i], LV_OBJ_FLAG_HIDDEN);
                lv_obj_set_style_opa(dealer_cards[i], 0, 0);
            }
        }
    }
    
    // Re-enable the buttons
    lv_obj_clear_state(ui_hitBtn, LV_STATE_DISABLED);
    lv_obj_clear_state(ui_standBtn, LV_STATE_DISABLED);
}

// Function to handle the stand button click
void standBtnClicked(lv_event_t * e)
{
    // Debug print
    printf("Stand button clicked!\n");
    
    uint32_t current_time = lv_tick_get();
    
    // Check if enough time has passed since last button press
    if(current_time - last_stand_btn_time < 500) {
        printf("Debounce prevented stand button processing: %u ms since last press\n", 
               (unsigned int)(current_time - last_stand_btn_time));
        return;  // Exit without processing if pressed too soon
    }
    
    // Check if dealer turn is already in progress
    if (dealer_turn_in_progress) {
        printf("Dealer turn already in progress, ignoring stand button\n");
        return;  // Exit if dealer's turn is already happening
    }
    
    // Disable back button during dealer's turn
    lv_obj_add_state(ui_backButtonSlots2, LV_STATE_DISABLED);
    printf("Back button disabled during dealer's turn\n");
    
    // Set the dealer_turn_in_progress flag to prevent multiple clicks
    dealer_turn_in_progress = true;
    
    // Update the last press time
    last_stand_btn_time = current_time;
    
    // Disable both hit and stand buttons during dealer's turn
    lv_obj_add_state(ui_hitBtn, LV_STATE_DISABLED);
    lv_obj_add_state(ui_standBtn, LV_STATE_DISABLED);
    printf("Disabled hit and stand buttons\n");
    
    // Initialize the dealer cards array if not done yet
    if (!dealer_cards_initialized) {
        printf("Initializing dealer cards array\n");
        dealer_cards[0] = ui_dealercard1;
        dealer_cards[1] = ui_dealercard2;
        dealer_cards[2] = ui_dealercard3;
        dealer_cards[3] = ui_dealercard4;
        dealer_cards[4] = ui_dealercard5;
        dealer_cards_initialized = true;
    }
    
    printf("Starting dealer's turn\n");
    
    // Flip the dealer's second card
    flip_dealer_card();
}

// Function to flip the dealer's second card
static void flip_dealer_card() {
    printf("Flipping dealer's second card\n");
    
    // Make sure the card is visible
    lv_obj_clear_flag(dealer_cards[0], LV_OBJ_FLAG_HIDDEN);
    
    
    // Set a random card for the dealer's first card
    set_card(dealer_cards[0], NULL, false);
    
    // Use the cardFlip_Animation from SquareLine Studio
    cardFlip_Animation(dealer_cards[0], 0);

	mp3_play_advertisement_with_stop(10, 20);


	char score_text[10];
    sprintf(score_text, "%d", get_dealer_hand_value());
    lv_label_set_text(ui_dealerPoints, score_text);
    printf("Dealer's score: %s\n", score_text);
    

    // Create a timer to start the dealer's turn after the animation completes
    // The cardFlip animation takes about 1000ms, so we set our timer accordingly
    lv_timer_t *flip_timer = lv_timer_create(dealer_turn_start_timer_cb, 1000, NULL);
    lv_timer_set_repeat_count(flip_timer, 1);
}

// Callback to be called after the flip animation timer finishes
static void dealer_turn_start_timer_cb(lv_timer_t * timer) {
    printf("Starting dealer's turn\n");
    
    // Update dealer's score display

    
    // Set current_dealer_card to 1 (for the second card)
    current_dealer_card = 1;

	set_card(dealer_cards[1], NULL, false);
    
    // Use the cardFlip_Animation from SquareLine Studio
    cardFlip_Animation(dealer_cards[1], 0);


	mp3_play_advertisement_with_stop(10, 20);
	char score_text[10];
    sprintf(score_text, "%d", get_dealer_hand_value());
    lv_label_set_text(ui_dealerPoints, score_text);
    printf("Dealer's score: %s\n", score_text);
    
    // Start the dealer's turn
    dealer_turn_timer = lv_timer_create(dealer_turn_cb, 1000, NULL);
    lv_timer_set_repeat_count(dealer_turn_timer, 1);
}

// Function to handle dealer's turn
static void dealer_turn_cb(lv_timer_t *timer) {
    int dealer_value = get_dealer_hand_value();

	money_label_black_jack = ui_comp_get_child(ui_coinAmountLabelBlackJack, UI_COMP_COINAMONTLABEL_COINAMONTLABEL);


    printf("Dealer's turn - current value: %d\n", dealer_value);
    
    // If dealer has 16 or less, draw another card
    if (dealer_value <= 16 && current_dealer_card < 5) {
        printf("Dealer drawing card %d\n", current_dealer_card);
        current_dealer_card++;

        // Make sure we don't exceed the array bounds
        if (current_dealer_card >= 2) {
            // For cards 3-5, use cardPull animation
            // Set opacity to 255 (visible)
            
            
            // Make the card visible if it was hidden
            lv_obj_clear_flag(dealer_cards[current_dealer_card], LV_OBJ_FLAG_HIDDEN);
            
            // Set a random card (false indicates it's a dealer card)
            set_card(dealer_cards[current_dealer_card], NULL, false);
            
            // Update dealer's score display
            char score_text[10];
            sprintf(score_text, "%d", get_dealer_hand_value());
            lv_label_set_text(ui_dealerPoints, score_text);
            printf("Dealer's new score: %s\n", score_text);
            
            // Animate the card using SquareLine Studio animation
            cardPullAnim_Animation(dealer_cards[current_dealer_card], 0);
            
			mp3_play_advertisement_with_stop(10, 20);

            // Move to the next card
            
            // Schedule the next dealer action
            dealer_turn_timer = lv_timer_create(dealer_turn_cb, 1000, NULL);
            lv_timer_set_repeat_count(dealer_turn_timer, 1);
        } else {
            // This should not happen normally, but just in case
            printf("Unexpected dealer card index: %d, moving to next card\n", current_dealer_card);
            
            // Move to the next card and continue
            current_dealer_card = 2;
            dealer_turn_timer = lv_timer_create(dealer_turn_cb, 500, NULL);
            lv_timer_set_repeat_count(dealer_turn_timer, 1);
        }
    } else {
        // Dealer stands (17 or more, or has 5 cards)
        printf("Dealer stands with %d\n", dealer_value);
        
        // Update the dealer's score display
        char score_text[10];
        sprintf(score_text, "%d", get_dealer_hand_value());
        lv_label_set_text(ui_dealerPoints, score_text);
        
        // Determine the winner using our function
        int result = determine_blackjack_winner();
        printf("Game result: %d (1=player win, -1=dealer win, 0=push)\n", result);
        
        // Handle the result
        if (result > 0) {
            // Player wins
            printf("Player wins!\n");

            
            // Update player's money (example - adjust as needed for your game logic)
            int bet_amount = get_bet_amount(); // Get your actual bet amount

            
            // Double payout for blackjack, regular payout otherwise
            if (get_player_hand_value() == 21 && get_player_card_count() == 2) {
                // Blackjack pays 3:2
				blackJackNotif_Animation(ui_bjnotf, 0);
                update_money(bet_amount * 5, 1000, true, money_label_black_jack);
                printf("Blackjack! Paying 3:2 (%d)\n", (int)(bet_amount * 1.5));
            } else {
                // Regular win pays 1:1
				blackJackNotif_Animation(ui_winnotf, 0);
				mp3_play_advertisement_with_stop(8, 200);
                update_money(bet_amount * 3, 1000, true, money_label_black_jack);
                printf("Regular win! Paying 1:1 (%d)\n", bet_amount);
            }
            
        } else if (result < 0) {
            // Dealer wins
            printf("Dealer wins!\n");
            blackJackNotif_Animation(ui_losenotf, 0);
			mp3_play_advertisement_with_stop(9, 200);
            // Update player's money (example)
            int bet_amount = 100; // Get your actual bet amount
            bet_amount_black_jack = ui_comp_get_child(ui_betAmountBlackJack, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
            if (bet_amount_black_jack != NULL) {
                bet_amount = get_bet_amount();
            }
            update_money(-bet_amount, 1000, true, money_label_black_jack);
            printf("Player loses %d\n", bet_amount);
            
        } else {
            // Push/Tie
            printf("Push (tie)!\n");
            // You can use either win or lose notification, or create a new one for push
            //blackJackNotif_Animation(ui_winnotf, 0);
            
            // No money change on push
        }
        
        // Reset dealer_turn_in_progress flag
        dealer_turn_in_progress = false;
        
        // Schedule game restart after notification (3 seconds)
        printf("Scheduling game restart in 3 seconds\n");
        restart_game_timer = lv_timer_create(restart_game_cb, 1500, NULL);
        lv_timer_set_repeat_count(restart_game_timer, 1);
    }
}

// Function to restart the game after notification
static void restart_game_cb(lv_timer_t *timer) {

    printf("Restarting blackjack game\n");
    
    // Instead of canceling timers which causes crashes, just set them to NULL
    // so they can be reused
    dealer_turn_timer = NULL;
    blackjack_buttons_timer = NULL;
    
    // Reset all game state
    reset_player_cards_arr();
    reset_dealer_cards_arr();
    reset_deck();
    
    // Reset card counters
    current_player_card = 0;
    current_dealer_card = 0;
    
    // Reset dealer_turn_in_progress flag
    dealer_turn_in_progress = false;
    
    // Reset last button press times
    last_hit_btn_time = 0;
    last_stand_btn_time = 0;
    
    // Reset score displays
    lv_label_set_text(ui_playerPoints, "0");
    lv_label_set_text(ui_dealerPoints, "0");
    
    // Reset visual UI elements (this should be done after resetting the internal state)
    reset_player_cards();
    reset_dealer_cards();
    
    // Reset specific UI elements - make them visible
    lv_obj_set_style_opa(ui_pointsBar, 255, 0);
    lv_obj_set_style_opa(ui_pointsboxDealer, 255, 0);
    lv_obj_set_style_opa(ui_playercardsframe, 255, 0);
    lv_obj_set_style_opa(ui_pointsboxPlayer, 255, 0);
    lv_obj_set_style_opa(ui_standBtn, 255, 0);
    lv_obj_set_style_opa(ui_hitBtn, 255, 0);
    lv_obj_set_style_opa(ui_dealerPoints, 255, 0);
    lv_obj_set_style_opa(ui_playerPoints, 255, 0);
    
    // Setup dealer's initial cards (both facing back)
    if (dealer_cards_initialized) {
        // Make both dealer cards visible with back image
        for (int i = 0; i < 2; i++) {
            printf("Displaying dealer card %d\n", i);
            lv_obj_clear_flag(dealer_cards[i], LV_OBJ_FLAG_HIDDEN);
            lv_image_set_src(dealer_cards[i], get_card_image("BACK"));
            cardPullAnim_Animation(dealer_cards[i], i * 200); // Animate with slight delay
        }
        
        // Hide the remaining dealer cards
        for (int i = 2; i < 5; i++) {
            lv_obj_add_flag(dealer_cards[i], LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_opa(dealer_cards[i], 0, 0);
        }
    }
    
    // Re-enable hit button, but keep stand button disabled until player has at least 2 cards
    lv_obj_clear_state(ui_hitBtn, LV_STATE_DISABLED);
    lv_obj_add_state(ui_standBtn, LV_STATE_DISABLED);
    lv_obj_clear_state(ui_backButtonSlots2, LV_STATE_DISABLED);
    printf("Hit button re-enabled, stand button disabled until player has at least 2 cards\n");
}

void hitBtnClicked(lv_event_t * e)
{
    printf("Hit button clicked\n");
	
    
    uint32_t current_time = lv_tick_get();
    
    // Check if enough time has passed since last button press
    if(current_time - last_hit_btn_time < 500) {
        printf("Debounce prevented hit button processing\n");
        return;  // Exit without processing if pressed too soon
    }
    
    // Disable back button during gameplay
    lv_obj_add_state(ui_backButtonSlots2, LV_STATE_DISABLED);
    printf("Back button disabled during gameplay\n");

    mp3_play_advertisement_with_stop(10, 20);

    // Update the last press time
    last_hit_btn_time = current_time;
    
    // Initialize the player cards array if not done yet
    if (!player_cards_initialized) {
        printf("Initializing player cards array\n");
        player_cards[0] = ui_playerCard1;
        player_cards[1] = ui_playerCard2;
        player_cards[2] = ui_playerCard3;
        player_cards[3] = ui_playerCard4;
        player_cards[4] = ui_playerCard5;
        player_cards_initialized = true;
    }
    
    // Make sure we don't exceed the array bounds
    if (current_player_card < 5) {
        printf("Drawing player card %d\n", current_player_card);
        
        // Make sure the card is fully visible
        
        
        // Make the card visible if it was hidden
        lv_obj_clear_flag(player_cards[current_player_card], LV_OBJ_FLAG_HIDDEN);
        
        // Set a random card (true indicates it's a player card)
        set_card(player_cards[current_player_card], NULL, true);
        
        // Update player's score display
        char score_text[10];
        sprintf(score_text, "%d", get_player_hand_value());
        lv_label_set_text(ui_playerPoints, score_text);
        printf("Player's score: %s\n", score_text);
        
        // Animate the card
        cardPullAnim_Animation(player_cards[current_player_card], 0);
        
        // Move to the next card
        current_player_card++;
        
        // Enable stand button when player has at least 2 cards
        if (current_player_card >= 2) {
            lv_obj_clear_state(ui_standBtn, LV_STATE_DISABLED);
            printf("Stand button enabled - player has %d cards\n", current_player_card);
        }
        
        // Check if player busted (over 21)
        if (get_player_hand_value() > 21) {
            printf("Player busted with %d\n", get_player_hand_value());
            
            // Player busted
            lv_obj_add_state(ui_hitBtn, LV_STATE_DISABLED);
            lv_obj_add_state(ui_standBtn, LV_STATE_DISABLED);
            
            // Show lose notification
            blackJackNotif_Animation(ui_losenotf, 500);
            mp3_play_advertisement_with_stop(9, 200);

            // Update player's money (loss)
            int bet_amount = 100; // Default bet
            bet_amount_black_jack = ui_comp_get_child(ui_betAmountBlackJack, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
            if (bet_amount_black_jack != NULL) {
                bet_amount = get_bet_amount();
            }
			money_label_black_jack = ui_comp_get_child(ui_coinAmountLabelBlackJack, UI_COMP_COINAMONTLABEL_COINAMONTLABEL);

            update_money(-bet_amount, 1000, true, money_label_black_jack);
            printf("Player loses %d\n", bet_amount);
            
            // Schedule game restart - don't call start_new_blackjack_game() directly
            printf("Scheduling game restart in 3 seconds\n");
            restart_game_timer = lv_timer_create(restart_game_cb, 3000, NULL);
            lv_timer_set_repeat_count(restart_game_timer, 1);
        }
        
        // Disable the hit button if we've reached the maximum number of cards
        if (current_player_card >= 5) {
            printf("Player has maximum 5 cards, disabling hit button\n");
            lv_obj_add_state(ui_hitBtn, LV_STATE_DISABLED);
        }
    } else {
        printf("Cannot draw more cards, already at maximum\n");
    }
}

// Function to reset player cards
static void reset_player_cards() {
    printf("Resetting player cards\n");
    
    // Reset player card array
    if (player_cards_initialized) {
        for (int i = 0; i < 5; i++) {
            lv_obj_add_flag(player_cards[i], LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_opa(player_cards[i], 0, 0);
        }
    }
}

// Function to reset dealer cards
static void reset_dealer_cards() {
    printf("Resetting dealer cards\n");
    
    // Reset dealer card array
    if (dealer_cards_initialized) {
        for (int i = 0; i < 5; i++) {
            lv_obj_add_flag(dealer_cards[i], LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_opa(dealer_cards[i], 0, 0);
        }
    }
}

// Timer callback function to enable the back button
static void enable_back_button_cb(lv_timer_t *timer) {
    // Enable the back button
    lv_obj_clear_state(ui_backButtonSlots2, LV_STATE_DISABLED);
    printf("Back button enabled after delay\n");
    
    // Enable hit button
    lv_obj_clear_state(ui_hitBtn, LV_STATE_DISABLED);
    
    // Stand button remains disabled until player has at least 2 cards
    // Keep ui_standBtn disabled - will be enabled after player has at least 2 cards
    lv_obj_add_state(ui_standBtn, LV_STATE_DISABLED);
    printf("Hit button enabled, stand button remains disabled until player has at least 2 cards\n");
    
    // Delete the timer since we only need it once
    lv_timer_del(timer);
    back_button_enable_timer = NULL;
}

// Function called when the blackjack screen is loaded
void blackJackLoaded(lv_event_t * e) {
	mp3_stop_repeat_with_delay(200);
	mp3_play_track_with_delay(6, 200);
	mp3_start_repeat_with_delay(200);
    printf("BlackJack screen loaded\n");
    
    // Disable the back button for 5 seconds to prevent accidental navigation during animations
    lv_obj_add_state(ui_backButtonSlots2, LV_STATE_DISABLED);
    
    // Also disable hit and stand buttons for 5 seconds
    lv_obj_add_state(ui_hitBtn, LV_STATE_DISABLED);
    lv_obj_add_state(ui_standBtn, LV_STATE_DISABLED);
    printf("Back, hit, and stand buttons disabled for 5 seconds\n");
    
    // Create a timer to re-enable the buttons after 5 seconds
    back_button_enable_timer = lv_timer_create(enable_back_button_cb, 5000, NULL);
    lv_timer_set_repeat_count(back_button_enable_timer, 1);  // Run the timer only once
    
    // Initialize the player cards array if not done yet
    if (!player_cards_initialized) {
        player_cards[0] = ui_playerCard1;
        player_cards[1] = ui_playerCard2;
        player_cards[2] = ui_playerCard3;
        player_cards[3] = ui_playerCard4;
        player_cards[4] = ui_playerCard5;
        player_cards_initialized = true;
    }
    
    // Initialize the dealer cards array if not done yet
    if (!dealer_cards_initialized) {
        dealer_cards[0] = ui_dealercard1;
        dealer_cards[1] = ui_dealercard2;
        dealer_cards[2] = ui_dealercard3;
        dealer_cards[3] = ui_dealercard4;
        dealer_cards[4] = ui_dealercard5;
        dealer_cards_initialized = true;
    }
    
    // Reset card counters
    current_player_card = 0;
    current_dealer_card = 0;
    
    // Reset dealer_turn_in_progress flag
    dealer_turn_in_progress = false;
    
    // Reset score displays
    lv_label_set_text(ui_playerPoints, "0");
    lv_label_set_text(ui_dealerPoints, "0");
    
    // Reset player and dealer cards first
    reset_player_cards();
    reset_dealer_cards();
    
    // Setup dealer's initial cards (both facing back)
    if (dealer_cards_initialized) {
        // Make both dealer cards visible
		mp3_play_advertisement_with_stop(11, 500);
        for (int i = 0; i < 2; i++) {
            printf("Setting up dealer card %d\n", i);
            lv_obj_clear_flag(dealer_cards[i], LV_OBJ_FLAG_HIDDEN);
            lv_image_set_src(dealer_cards[i], get_card_image("BACK"));
            //cardPullAnim_Animation(dealer_cards[i], i * 200); // Animate with delay
        }
        
        // Hide the remaining dealer cards
        for (int i = 2; i < 5; i++) {
            lv_obj_add_flag(dealer_cards[i], LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_opa(dealer_cards[i], 0, 0);
        }
    }
    
    // Make UI elements invisible
    lv_obj_set_style_opa(ui_pointsBar, 0, 0);
    lv_obj_set_style_opa(ui_pointsboxDealer, 0, 0);
    lv_obj_set_style_opa(ui_playercardsframe, 0, 0);
    lv_obj_set_style_opa(ui_pointsboxPlayer, 0, 0);
    lv_obj_set_style_opa(ui_standBtn, 0, 0);
    lv_obj_set_style_opa(ui_hitBtn, 0, 0);
    lv_obj_set_style_opa(ui_dealerPoints, 0, 0);
    lv_obj_set_style_opa(ui_playerPoints, 0, 0);
    
    // Setup bet amount widgets if needed
    bet_amount_black_jack = ui_comp_get_child(ui_betAmountBlackJack, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
    if (bet_amount_black_jack != NULL) {
        set_bet_value(bet_amount_black_jack, 0);
    }
	money_label_black_jack = ui_comp_get_child(ui_coinAmountLabelBlackJack, UI_COMP_COINAMONTLABEL_COINAMONTLABEL);
	update_money(0, 1000, true, money_label_black_jack);
}

// Function to deal the initial cards
// Function to handle bet increase
void plusBetBlackJack(lv_event_t * e) {
	
	bet_amount_black_jack = ui_comp_get_child(ui_betAmountBlackJack, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
	set_bet_value(bet_amount_black_jack, 100);
}

// Function to handle bet decrease
void minusBetBlackJack(lv_event_t * e) {
	bet_amount_black_jack = ui_comp_get_child(ui_betAmountBlackJack, UI_COMP_BETAMOUNTSLOTS_BETAMOUNTSLOTS);
	set_bet_value(bet_amount_black_jack, -100);
}
